# Блок-схема процесса кросспостинга в CrossPoster

## Общий процесс кросспостинга

```mermaid
graph TD
    A[Начало] --> B[Планировщик запускает задачу проверки новых постов]
    B --> C{Проверка новых постов в VK?}
    C -->|Нет новых постов| D[Ждать следующего цикла проверки]
    C -->|Есть новые посты| E[Сохранить новый пост в базу данных]
    E --> F[Создать задачу репостинга в другие соцсети]
    F --> G[Добавить задачу в очередь Celery]
    G --> H[Воркер обрабатывает задачу]
    H --> I{Выбор социальной сети для репоста}
    I -->|Telegram| J[Подготовить пост для Telegram]
    I -->|Instagram| K[Подготовить пост для Instagram]
    I -->|Pinterest| L[Подготовить пост для Pinterest]
    I -->|YouTube| M[Подготовить пост для YouTube]
    
    J --> N[Отправить пост в Telegram через API]
    K --> O[Отправить пост в Instagram через API]
    L --> P[Отправить пост в Pinterest через API]
    M --> Q[Отправить пост в YouTube через API]
    
    N --> R[Сохранить результат в статистику]
    O --> R
    P --> R
    Q --> R
    R --> S{Есть ещё соцсети для репоста?}
    S -->|Да| I
    S -->|Нет| T[Завершить задачу]
    T --> D
    
    D --> B
```

## Подробный процесс проверки новых постов

```mermaid
graph TD
    A[Планировщик задач] --> B[Вызов функции check_vk_posts]
    B --> C[Подключение к VK API]
    C --> D[Получение последних постов из группы/профиля]
    D --> E[Сравнение с уже известными постами в базе данных]
    E --> F{Есть новые посты?}
    F -->|Нет| G[Завершить задачу]
    F -->|Да| H[Для каждого нового поста: сохранить в базу]
    H --> I[Для каждого нового поста: создать задачу репостинга]
    I --> J[Отправить задачу в очередь Celery]
    J --> K[Воркер берет задачу из очереди]
    K --> L[Выполняет репостинг в другие соцсети]
```

## Процесс репостинга через Celery

```mermaid
graph LR
    A[Celery Worker] --> B[Получает задачу репостинга]
    B --> C[Определяет источник поста]
    C --> D[Определяет целевые соцсети]
    D --> E[Для каждой целевой соцсети:]
    E --> F[Подготовка контента]
    F --> G[Преобразование медиа-файлов под формат целевой соцсети]
    G --> H[Вызов API целевой соцсети]
    H --> I{Успешно отправлено?}
    I -->|Да| J[Сохранить статус отправки]
    I -->|Нет| K[Повторить отправку или пометить как ошибку]
    J --> L[Обновить статистику]
    K --> L
    L --> M[Завершить задачу]
```

## Архитектура системы

```mermaid
graph TB
    subgraph "Клиентская зона"
        A[Web API] 
        A1[Пользовательский интерфейс]
    end
    
    subgraph "Серверная зона"
        B[База данных PostgreSQL]
        C[Redis (брокер сообщений)]
        D[Celery Workers]
        E[Планировщик (Scheduler)]
    end
    
    subgraph "Социальные сети"
        F[VK API]
        G[Telegram API]
        H[Instagram API]
        I[Pinterest API]
        J[Youtube API]
    end
    
    A <--> B
    A <--> C
    E --> D
    D --> C
    D --> B
    D --> F
    D --> G
    D --> H
    D --> I
    D --> J
```

## Процесс добавления новых социальных сетей

```mermaid
graph TD
    A[Разработчик] --> B[Создает новый клиент для социальной сети]
    B --> C[Наследует базовый класс социального клиента]
    C --> D[Реализует методы: get_latest_posts, post_to_channel]
    D --> E[Добавляет в систему задач Celery]
    E --> F[Регистрирует в планировщике]
    F --> G[Тестирует интеграцию]
    G --> H[Обновляет документацию]